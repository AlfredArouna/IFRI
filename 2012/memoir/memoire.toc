\select@language {english}
\contentsline {chapter}{R\IeC {\'e}sum\IeC {\'e} / Abstract}{i}{chapter*.2}
\contentsline {paragraph}{}{i}{chapter*.2}
\select@language {english}
\contentsline {paragraph}{}{i}{chapter*.2}
\contentsline {chapter}{Glossaire}{i}{section*.1}
\select@language {french}
\select@language {french}
\contentsline {chapter}{Remerciements}{vi}{chapter*.6}
\contentsline {paragraph}{}{vi}{chapter*.6}
\contentsline {paragraph}{}{vi}{chapter*.6}
\contentsline {paragraph}{}{vi}{chapter*.6}
\contentsline {chapter}{\numberline {1}Le Network Administration Visualized}{1}{chapter.1}
\contentsline {section}{\numberline {I}Pr\IeC {\'e}sentation rapide}{1}{section.1.1}
\contentsline {paragraph}{Int\IeC {\'e}r\IeC {\^e}t du NAV\\}{1}{section.1.1}
\contentsline {paragraph}{}{1}{section.1.1}
\contentsline {paragraph}{}{2}{section.1.1}
\contentsline {section}{\numberline {II}Limites de NAV}{2}{section.1.2}
\contentsline {subsection}{\numberline {1)}Domaines d'utilisation}{2}{subsection.1.2.1}
\contentsline {subsection}{\numberline {2)}Fonctionnalit\IeC {\'e}s}{2}{subsection.1.2.2}
\contentsline {chapter}{\numberline {2}Initialisation automatique de la base de donn\IeC {\'e}es}{3}{chapter.2}
\contentsline {section}{\numberline {I}Initialisation automatique de la base de donn\IeC {\'e}es gr\IeC {\^a}ce \IeC {\`a} SNMP}{3}{section.2.1}
\contentsline {subsection}{\numberline {1)}\IeC {\'E}tudes relatives \IeC {\`a} la d\IeC {\'e}couverte de la typologie r\IeC {\'e}seau avec SNMP}{3}{subsection.2.1.1}
\contentsline {section}{\numberline {II}Les algorithmes}{4}{section.2.2}
\contentsline {paragraph}{Notre algorithme est une mise en commun des quatre premi\IeC {\`e}res \IeC {\'e}tapes propos\IeC {\'e}es par Pandey and et. al. (2011) et de l'algorithme propos\IeC {\'e} pour la fonctionnalit\IeC {\'e} de d\IeC {\'e}couverte des \IeC {\'e}quipements du r\IeC {\'e}seau. Nous ne prenons pas en compte la d\IeC {\'e}couverte de la connectivit\IeC {\'e} (topologie) et des VLAN. \texttt {ipdevpoll} s'occupe d\IeC {\'e}j\IeC {\`a} de ces deux derni\IeC {\`e}res fonctionnalit\IeC {\'e}s dans NAV. \\}{5}{section.2.2}
\contentsline {subsection}{\numberline {1)}Starting Point}{5}{subsection.2.2.1}
\contentsline {subsection}{\numberline {2)}Device Discovery}{6}{subsection.2.2.2}
\contentsline {paragraph}{}{6}{subsection.2.2.2}
\contentsline {subsubsection}{\numberline {1)}Device discovery using next hop mechanism}{8}{subsubsection.2.2.2.1}
\contentsline {subsubsection}{\numberline {2)}Device discovery using ARP cache entries}{8}{subsubsection.2.2.2.2}
\contentsline {paragraph}{Le probl\IeC {\`e}me de l'ARP\\}{8}{subsubsection.2.2.2.2}
\contentsline {subsection}{\numberline {3)}Device grouping}{8}{subsection.2.2.3}
\contentsline {paragraph}{L'\IeC {\'e}tape du device grouping s'op\IeC {\`e}re \IeC {\`a} chaque ajout d'un nouvel \IeC {\'e}quipement dans \texttt {D[]}. C'est une \IeC {\'e}tape ex\IeC {\'e}cut\IeC {\'e}e aussi bien au niveau du \emph {Device discovery using next hop mechanism} que du \emph {Device discovery using ARP cache entries}.}{9}{algorithm.2.3}
\contentsline {subsection}{\numberline {4)}Device type discovery}{9}{subsection.2.2.4}
\contentsline {paragraph}{Router\\}{9}{algorithm.2.4}
\contentsline {paragraph}{Host\\}{10}{algorithm.2.4}
\contentsline {paragraph}{Bridges\\}{10}{algorithm.2.4}
\contentsline {subsection}{\numberline {5)}Create Bulk format}{11}{subsection.2.2.5}
\contentsline {subsection}{\numberline {6)}Store in Db}{11}{subsection.2.2.6}
\contentsline {section}{\numberline {III}Impl\IeC {\'e}mentation, tests et r\IeC {\'e}sultats}{11}{section.2.3}
\contentsline {subsection}{\numberline {1)}Structuration}{11}{subsection.2.3.1}
\contentsline {subsection}{\numberline {2)}La classe SeebDB}{13}{subsection.2.3.2}
\contentsline {subsubsection}{\numberline {1)}\_\_init\_\_}{13}{subsubsection.2.3.2.1}
\contentsline {subsubsection}{\numberline {2)}request\_snmp\_parameters}{13}{subsubsection.2.3.2.2}
\contentsline {subsubsection}{\numberline {3)}check\_snmp}{14}{subsubsection.2.3.2.3}
\contentsline {subsubsection}{\numberline {4)}device\_discovery}{14}{subsubsection.2.3.2.4}
\contentsline {subsubsection}{\numberline {5)}get\_device\_type\\}{14}{subsubsection.2.3.2.5}
\contentsline {subsubsection}{\numberline {6)}create\_bulk\_format\\}{14}{subsubsection.2.3.2.6}
\contentsline {subsubsection}{\numberline {7)}catch\_exit}{14}{subsubsection.2.3.2.7}
\contentsline {subsection}{\numberline {3)}La classe GetIndirectNextHop}{15}{subsection.2.3.3}
\contentsline {subsubsection}{\numberline {1)}\_\_ini\_\_}{15}{subsubsection.2.3.3.1}
\contentsline {subsubsection}{\numberline {2)}run}{15}{subsubsection.2.3.3.2}
\contentsline {subsection}{\numberline {4)}La classe DeviceGrouping}{15}{subsection.2.3.4}
\contentsline {subsection}{\numberline {5)}La classe GetLocalNetAddress}{16}{subsection.2.3.5}
\contentsline {subsection}{\numberline {6)}\IeC {\'E}valuation du code}{16}{subsection.2.3.6}
\contentsline {subsection}{\numberline {7)}Test dans un environnement virtuel}{16}{subsection.2.3.7}
\contentsline {subsubsection}{\numberline {1)}R\IeC {\'e}seau virtuel de test des impl\IeC {\'e}mentations des algorithmes}{16}{subsubsection.2.3.7.1}
\contentsline {subsubsection}{\numberline {2)}R\IeC {\'e}sultats}{19}{subsubsection.2.3.7.2}
\contentsline {chapter}{Bibliographie}{22}{chapter*.11}
